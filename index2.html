<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brownian Motion</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            height: 100vh;
            background: #ffffff;
        }
        canvas {
            border: 3px solid #04d10e;
            background: #ffffff00;
            margin-left: 0px;
        }
        #plot {
            width: 800px;
            height: 600px;
        }
        a {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #04d10e;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        a:hover {
            background: #03a00c;
        }
    </style>
</head>
<body>
    <a href="index.html">Single Particle ‚Üê</a>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="plot"></div>
    <div id="info" style="position: absolute; bottom: 20px; left: 20px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif;">
        <strong>Controls:</strong><br>
        Press 's' to Start/Pause<br>
        Press 'r' to Reset<br>
        Press 'a' to Toggle Accurate Model <br>
        Press 'd' to execute single step<br>
        <br>
        <strong>Status:</strong> Paused<br>
        <strong>Model:</strong> Simple
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        let accuratemodel = false;

        function gaussian(mean, stdDev) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            let z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
            return [z0 * stdDev + mean, z1 * stdDev + mean];
        }
        
        // Particle properties
        const NUM_PARTICLES = 900; // Change this number to add more/fewer particles
        const radius = 2;
        let highDiffusionRegion = 0;
        let lowDiffusionRegion = 0;
        let timeSteps = 0;
        let paused= true;
        const Dhigh = 100;
        const Dlow = Dhigh / 3;
        const dt = 0.1;
        let sd = Math.sqrt(2*Dhigh*dt);
        let TotalParticlesHigh = 0;
        let averageHigh = 0;

        // Create array of particles
        const particles = [];
        for (let i = 0; i < NUM_PARTICLES; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        }

                window.addEventListener('keydown', (e) => {
            if (e.key === 's'){
                paused = !paused;
                // Update info div to tell the user the current state
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}`;
            }
            if (e.key === 'r'){
                // Reset particle position
                particles.forEach(particle => {
                    particle.x = Math.random() * canvas.width;
                    particle.y = Math.random() * canvas.height;
                });
                timeSteps = 0;
                highDiffusionRegion = 0;
                lowDiffusionRegion = 0;
            }
            if (e.key === 'a'){
                accuratemodel = !accuratemodel;
                // Update info div to tell the user the current model
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}`;  

            }
            if (e.key === 'd'){
                singleStep();
            }
        });
        
        function animate() {

            if(!paused){
                singleStep();
            }
            requestAnimationFrame(animate);
        }
        function singleStep() {
            lowDiffusionRegion = 0;
            highDiffusionRegion = 0;
            timeSteps++;
            
            
            particles.forEach(particle => {
                let currentRegion 
                const previousX = particle.x;
                const previousY = particle.y;
                let Di; // initial diffusion coefficient
                let Df; // final diffusion coefficient
                if (previousX < canvas.width / 4 || previousX > 3 * canvas.width / 4) {
                    Di = Dlow;
                    lowDiffusionRegion++;
                    currentRegion = 'low';
                } else {
                    Di = Dhigh;
                    highDiffusionRegion++;
                    currentRegion = 'high';
                }
                sd = Math.sqrt(2*Di*dt);
                const [gx, gy] = gaussian(0, 1);
                let [dx, dy] = [gx * sd, gy * sd];

                let finalX = ((previousX + dx) % canvas.width + canvas.width) % canvas.width;
                let finalY = ((previousY + dy) % canvas.height + canvas.height) % canvas.height;
                let nextRegion;
                if (finalX < canvas.width / 4 || finalX > 3 * canvas.width / 4) {
                    nextRegion = 'low';
                } else {
                    nextRegion = 'high';
                }

                if (currentRegion !== nextRegion && accuratemodel) {
                    const distanceToBoundary1 = previousX - canvas.width / 4;
                    const distanceToBoundary2 = previousX - 3 * canvas.width / 4;
                    const distanceToBoundary = Math.min( 
                        Math.abs(previousX - canvas.width / 4),
                        Math.abs(previousX - 3 * canvas.width / 4)
                    );
                    //const closestBoundary = Math.abs(distanceToBoundary1) < Math.abs(distanceToBoundary2) ? canvas.width / 4 : 3 * canvas.width / 4;
                    const Df = nextRegion === 'high' ? Dhigh : Dlow;
                    const Di = currentRegion === 'high' ? Dhigh : Dlow;
                    const dtModified = dt - Math.pow(distanceToBoundary/gx, 2) / (2 * Di);
                    const dXf= Math.sqrt(2*Df *dtModified) * gx;
                    const dYf= Math.sqrt(2*Df *dtModified) * gy;
                    finalX = previousX + dXf;
                    finalY = previousY + dYf; 
                    /* finalX = closestBoundary +dXf;
                    finalY = previousY + dYf; */

                
                }


                particle.x = finalX;
                particle.y = finalY;
                
            
            });  


          
            TotalParticlesHigh += highDiffusionRegion/NUM_PARTICLES;
            
          

            if (timeSteps % 20 === 0) {
            const newAverageHigh = TotalParticlesHigh / timeSteps;
            const convergance = Math.abs(newAverageHigh - averageHigh)
            averageHigh = newAverageHigh;
               // Clear canvas
            ctx.fillStyle = 'rgba(10, 50, 100, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(100, 50, 10, 1)';
            ctx.fillRect(canvas.width/4, 0, canvas.width/2, canvas.height); 
            // Update and draw each particle
                  // Draw particles
                particles.forEach(particle => {
                    // Draw particles

                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ff88';
                    ctx.fill();
                });
                updatePlot(highDiffusionRegion, lowDiffusionRegion);
                  // Display average proportion of particles in high diffusion region
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}<br>
                <strong>Time Steps:</strong> ${timeSteps}<br>
                <strong>Average Particles in High Diffusion Region:</strong> ${averageHigh.toFixed(5)}, Difference: ${convergance.toFixed(10)}`;
            }
           
        }
        function updatePlot(highDiffusionRegion, lowDiffusionRegion) {
          const data = [{
                x: ['High Diffusion', 'Low Diffusion'],
                y: [highDiffusionRegion, lowDiffusionRegion],
                type: 'bar',
                marker: {
                    color: ['rgba(100, 50, 10, 1)', 'rgba(10, 50, 100, 1)']
                }
            }];

            const layout = {
                title: 'number of Particles in Each Region',
                yaxis: { title: 'Number of Particles' },
                xaxis: { title: 'Region' }
            };

            Plotly.newPlot('plot', data, layout);
            
        }
        
        animate();
    </script>
</body>
</html>