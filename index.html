<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brownian Motion</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            height: 100vh;
            background: #dbf5ff;
        }
        canvas {
            border: 3px solid #04d10e;
            background: #ffffff00;
            margin-left: 0px;
        }
        #plot {
            width: 800px;
            height: 600px;
        }
        a {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #04d10e;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        a:hover {
            background: #03a00c;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1100" height="900" style="position: absolute; left:20px; top:20px;"></canvas>
    <div id="plot" style="position: absolute; top: 20px; right: 20px; width: 700px; height: 500px; border: 3px solid #04d10e; background: #ffffff;"></div>
    <div id="info" style="position: absolute; bottom: 20px; left: 20px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif;">
    </div>
	<div id="convergencePlot" style="position: absolute; bottom: 20px; right: 20px; width: 700px; height: 500px; border: 3px solid #04d10e; background: #ffffff;"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        let accuratemodel = false;

        function gaussian(mean, stdDev) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            let z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
            return [z0 * stdDev + mean, z1 * stdDev + mean];
        }
        
	let plotData = [{
  	x: ['High Diffusion', 'Low Diffusion'],
  	y: [0, 0],
  	type: 'bar',
  	marker: {
    	color: ['rgba(100, 50, 10, 1)', 'rgba(10, 50, 100, 1)']
  	}
	}];

	let plotLayout = {
  	title: 'Number of Particles in Each Region',
  	yaxis: { title: 'Number of Particles', rangemode: 'tozero' },
  	xaxis: { title: 'Region' }
	};

	let plotConvergence = [{
  	x: [],
  	y: [],
  	type: 'scatter',
  	mode: 'lines+markers',
  	name: 'Convergence',
  	marker: { color: 'rgba(0, 150, 255, 0.4)' }
	}, {
  	x: [],
  	y: [],
  	type: 'scatter',
  	mode: 'lines',
  	name: '50-step Moving Average',
  	line: { color: 'rgba(255, 100, 0, 0.8)', width: 3 }
	}];

	let convergenceLayout = {
        // make y axis logarithmic
  	title: 'Convergence of Average Proportion in High Diffusion Region',
  	yaxis: { title: 'Difference in Proportion', rangemode: 'tozero' },

  	xaxis: { title: 'Update Steps' }
	};

	Plotly.newPlot('plot', plotData, plotLayout);
    Plotly.newPlot('convergencePlot', plotConvergence, convergenceLayout);
        // Particle properties
        const NUM_PARTICLES = 10000; // Change this number to add more/fewer particles
        const radius = 1;
        let highDiffusionRegion = 0;
        let lowDiffusionRegion = 0;
        let timeSteps = 0;
        let paused= true;
        const Dhigh = 50;
        const Dlow = Dhigh / 3;
        const dt = 0.1;
        let averageHigh = 0.5;
        let averagevalues = [];
	const convergenceArray = [];

        // Create array of particles
        const particles = [];
        for (let i = 0; i < NUM_PARTICLES; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        }

                window.addEventListener('keydown', (e) => {
            if (e.key === 's'){
                paused = !paused;
                // Update info div to tell the user the current state
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}`;
            }
            if (e.key === 'r'){
                // Reset particle position
                particles.forEach(particle => {
                    particle.x = Math.random() * canvas.width;
                    particle.y = Math.random() * canvas.height;
                });
                timeSteps = 0;
                highDiffusionRegion = 0;
                lowDiffusionRegion = 0;
                // Reset convergence tracking
                averageHigh = 0.5;
                convergenceArray.length = 0;
                // Clear plots
                plotData[0].y = [0, 0];
                Plotly.redraw('plot');
                plotConvergence[0].x = [];
                plotConvergence[0].y = [];
                plotConvergence[1].x = [];
                plotConvergence[1].y = [];
                Plotly.redraw('convergencePlot');
            }
            if (e.key === 'a'){
                accuratemodel = !accuratemodel;
                // Update info div to tell the user the current model
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}`;  

            }
            if (e.key === 'd'){
                singleStep();
            }
        });
        
        function animate() {

            if(!paused){
                singleStep();
            }
            requestAnimationFrame(animate);
        }
        function singleStep() {
            lowDiffusionRegion = 0;
            highDiffusionRegion = 0;
            timeSteps++;
            
            
            particles.forEach(particle => {
                let currentRegion 
                const previousX = particle.x;
                const previousY = particle.y;
                let Di; // initial diffusion coefficient
                let Df; // final diffusion coefficient
                if (previousX < canvas.width / 4 || previousX > 3 * canvas.width / 4) {
                    Di = Dlow;
                    lowDiffusionRegion++;
                    currentRegion = 'low';
                } else {
                    Di = Dhigh;
                    highDiffusionRegion++;
                    currentRegion = 'high';
                }
                const sd = Math.sqrt(2*Di*dt);
                const [gx, gy] = gaussian(0, 1);
                let [dx, dy] = [gx * sd, gy * sd];

                let finalX = ((previousX + dx) % canvas.width + canvas.width) % canvas.width;
                let finalY = ((previousY + dy) % canvas.height + canvas.height) % canvas.height;
                let nextRegion;
                if (finalX < canvas.width / 4 || finalX > 3 * canvas.width / 4) {
                    nextRegion = 'low';
                } else {
                    nextRegion = 'high';
                }

                if (currentRegion !== nextRegion && accuratemodel) {
                    const distanceToBoundary1 = previousX - canvas.width / 4;
                    const distanceToBoundary2 = previousX - 3 * canvas.width / 4;
                    const distanceToBoundary = Math.min(
                        Math.abs(distanceToBoundary1),
                        Math.abs(distanceToBoundary2)
                    );
                    //const closestBoundary = distanceToBoundary === Math.abs(distanceToBoundary1)
                    //    ? canvas.width / 4
                    //    : 3 * canvas.width / 4;
                    const Df = nextRegion === 'high' ? Dhigh : Dlow;
                    const Di = currentRegion === 'high' ? Dhigh : Dlow;
                    //const timeOfArrival = Math.pow(distanceToBoundary / gx, 2) / (2 * Di);
                    //const dtModified = dt - timeOfArrival;
                    //const dXf= Math.sqrt(2*Df *dtModified) * gx;
                    //const dYf= Math.sqrt(2*Df *dtModified) * gy;

                    /* finalX = previousX + dXf;
                    finalY = previousY + dYf;  */

                   /*  const randomSign = (Math.random() < 0.5) ? -1 : 1;
                    finalX = closestBoundary + dXf*randomSign;
                    finalY = previousY + dYf;  */

                    const dXf2 = Math.sqrt(2*Df *dt) * gx;
                    const dYf2 = Math.sqrt(2*Df *dt) * gy;
                    finalX = previousX + dXf2;
                    finalY = previousY + dYf2;



                
                }


                particle.x = finalX;
                particle.y = finalY;
                
            
            });  


          
            
            ctx.fillStyle = 'rgba(10, 50, 100, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(100, 50, 10, 1)';
            ctx.fillRect(canvas.width/4, 0, canvas.width/2, canvas.height); 
            // Update and draw each particle
                  // Draw particles
             let firstParticle  = true;  
                particles.forEach(particle => {
                    // Draw particles
                    if (firstParticle) {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, radius*6, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0, 255, 0, 1)';
                        ctx.fill();
                    }
                    
                    firstParticle = false;
                });

            if (timeSteps % 100 === 0) {
            const newAverageHigh = highDiffusionRegion / NUM_PARTICLES;
            const convergance = newAverageHigh - averageHigh
	        convergenceArray.push(convergance );
                averagevalues.push(newAverageHigh);
            const average = averagevalues.reduce((sum, val) => sum + val, 0) / averagevalues.length;

            averageHigh = newAverageHigh;


               // Clear canvas
            
                updatePlot(highDiffusionRegion, lowDiffusionRegion);
                  // Display average proportion of particles in high diffusion region
                infoDiv.innerHTML = `<strong>Controls:</strong><br>
                Press 's' to ${paused ? 'Start' : 'Pause'}<br>
                Press 'r' to Reset<br>
                Press 'a' to Toggle Accurate Model<br>
                Press 'd' to execute single step<br>
                <br>
                <strong>Status:</strong> ${paused ? 'Paused' : 'Running'}<br>
                <strong>Model:</strong> ${accuratemodel ? 'Accurate' : 'Simple'}<br>
                <strong>Time Steps:</strong> ${timeSteps}<br>
                <strong>Average Particles in High Diffusion Region:</strong> ${averageHigh.toFixed(5)}, Difference: ${convergance.toFixed(10)}<br>
                <strong>Average over time:</strong> ${average.toFixed(5)}`;
            }
           
        }
        
	function updatePlot(highDiffusionRegion, lowDiffusionRegion) {
  		plotData[0].y[0] = highDiffusionRegion;
  		plotData[0].y[1] = lowDiffusionRegion;
  		Plotly.redraw('plot'); // or Plotly.react('plot', plotData, plotLayout);
		
		// Update convergence plot
		plotConvergence[0].x.push(timeSteps / 100);
  		plotConvergence[0].y.push(convergenceArray[convergenceArray.length - 1]);
		
		// Calculate 20-step moving average
		const windowSize = 50;
		if (convergenceArray.length >= windowSize) {
			const recentValues = convergenceArray.slice(-windowSize);
			const movingAvg = recentValues.reduce((sum, val) => sum + val, 0) / windowSize;
			plotConvergence[1].x.push(timeSteps / 100);
			plotConvergence[1].y.push(movingAvg);
		}
		
        //only plot last 100 points to avoid overload
        if (plotConvergence[0].x.length > 150) {
            plotConvergence[0].x.shift();
            plotConvergence[0].y.shift();
			if (plotConvergence[1].x.length > 0) {
				plotConvergence[1].x.shift();
				plotConvergence[1].y.shift();
			}
        }
        
  		Plotly.redraw('convergencePlot');
	}

        
        animate();
    </script>
</body>
</html>
